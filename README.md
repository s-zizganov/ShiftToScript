## AdvancedRobotDetection — детекция торговых роботов по потоку сделок Tinkoff Invest API

### Назначение

**AdvancedRobotDetection** — консольное Java‑приложение для онлайн‑детекции торговых роботов на основании потока сделок (trades) из Tinkoff Invest API.

Приложение:
- **подписывается** на сделки по всем российским акциям (валюта `RUB`);
- **агрегирует быстрые тики** в окно 50 мс для снижения шума;
- **анализирует интервалы** между сделками одинакового лота;
- **обнаруживает роботов** по стабильному интервалу между сделками;
- **ведёт список активных роботов** и печатает сообщение **только при их первом появлении**;
- **удаляет робота** из списка, если он «молчит» более 3 минут;
- выводит в лог тикер, интервал, лот и **время последнего тика в московском времени**.

---

### Внешние зависимости и окружение

- **Tinkoff Invest API (PIAPI)**:
  - `ru.tinkoff.piapi.core.InvestApi` — создание клиента;
  - `ru.tinkoff.piapi.core.stream.MarketDataStreamService` — стрим маркет‑данных;
  - `ru.tinkoff.piapi.contract.v1.*` — контракты (тип `Trade`, `MarketDataResponse`, `InstrumentStatus`, `Share` и т.д.).
- **gRPC**:
  - `io.grpc.stub.StreamObserver<MarketDataResponse>` — обработчик входящих сообщений стрима.
- **Java Standard Library**:
  - `java.time.Instant`, `ZoneId`, `DateTimeFormatter` — время и форматирование;
  - `java.util.*`, `java.util.concurrent.TimeUnit` — коллекции, поток управления.
- **Токен доступа**:
  - В `AdvancedRobotDetection.main` токен Tinkoff API сейчас **захардкожен** в поле `String token`.
  - Для продакшн‑использования рекомендуется вынести его в переменную окружения или конфигурационный файл.

---

### Основные параметры алгоритма

Все константы определены в `AdvancedRobotDetection`:

- **`MIN_SERIES_LENGTH = 3`**  
  Минимальное количество сделок в серии, необходимое для оценки интервала. Серии короче игнорируются.

- **`INTERVAL_TOLERANCE = 0.3`**  
  Допустимая относительная вариация интервалов между сделками.  
  Если отношение `std / mean > INTERVAL_TOLERANCE`, серия считается слишком шумной и не трактуется как робот.

- **`TIME_WINDOW_MS = 240000` (4 минуты)**  
  Длительность скользящего окна хранения сделок по FIGI. Все сделки старше `currentTime - TIME_WINDOW_MS` удаляются из буфера.

- **`MIN_LOT = 5`**  
  Минимальный объем сделки (количество лотов), который участвует в анализе. Сделки с объемом `< MIN_LOT` считаются шумом и отбрасываются.

- **`LOT_TOLERANCE = 0`**  
  Допустимое отклонение объема для объединения сделок в одну «группу лотов». Сейчас равен 0 — лоты должны быть строго идентичны.

- **`AGGREGATION_WINDOW_MS = 50`**  
  Окно агрегации тиков. Все сделки по одному FIGI, пришедшие в пределах 50 мс, агрегируются:
  - время агрегированного тика сдвигается на время последнего;
  - объемы суммируются.

- **`ROBOT_TIMEOUT_MS = 180000` (3 минуты)**  
  Если по конкретному роботу (комбинация `FIGI + лот`) нет подходящих сделок более 3 минут, он удаляется из списка активных роботов.

- **Формат и часовой пояс для времени**
  - `MOSCOW_ZONE = ZoneId.of("Europe/Moscow")`;
  - `TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm:ss")`.  
  Используется для отображения времени последнего тика в московском часовом поясе.

---

### Структуры данных

- **`tradesBuffers: Map<String, Deque<long[]>>`**  
  - Ключ: `FIGI` инструмента.  
  - Значение: двусторонняя очередь (`Deque<long[]>`), каждый элемент:
    - индекс `0` — `timestampMs` (время сделки в мс от эпохи);
    - индекс `1` — `quantity` (агрегированный объем в лотах).

- **`figiToTicker: Map<String, String>`**  
  - Ключ: `FIGI`, значение: `ticker`.  
  Заполняется при старте по списку российских акций.

- **`activeRobots: Map<String, RobotState>`**  
  - Ключ: строка вида `"<FIGI>|<lot>"`;
  - Значение: объект `RobotState`, описывающий состояние робота для конкретного FIGI и размера лота.

- **Внутренний класс `RobotState`**:
  - `figi` — FIGI инструмента;
  - `ticker` — тикер для удобного логирования;
  - `lot` — размер лота, по которому обнаружен робот;
  - `intervalSec` — оцененный средний интервал между сделками робота (в секундах);
  - `firstDetectedMs` — время первого обнаружения робота (мс от эпохи);
  - `lastTickMs` — время последнего релевантного тика робота.

Эти структуры используются для:
- хранения истории сделок по каждому инструменту;
- отображения FIGI → тикер;
- отслеживания текущего списка «активных» роботов.

---

### Жизненный цикл и запуск

1. **Создание API‑клиента**:
   - `InvestApi api = InvestApi.create(token);`
2. **Получение сервисов**:
   - `MarketDataStreamService` — стрим маркет‑данных;
   - `InstrumentsService` — для начального списка акций.
3. **Загрузка российских акций**:
   - `getSharesSync(InstrumentStatus.INSTRUMENT_STATUS_BASE)`,
   - фильтрация по валюте `RUB`,
   - заполнение `figiToTicker`,
   - подготовка списка FIGI для подписки.
4. **Создание `StreamObserver<MarketDataResponse>`**:
   - `onNext` — обработка сделок и запуск алгоритма детекции;
   - `onError` — лог ошибок;
   - `onCompleted` — лог завершения стрима.
5. **Создание и запуск стрима**:
   - `streamService.newStream("robot-detector", ...)`;
   - `subscription.subscribeTrades(figis);`.
6. **Удержание приложения в живом состоянии**:
   - `TimeUnit.DAYS.sleep(1);` — основной поток засыпает, приложение продолжает обрабатывать входящий поток данных через стрим.

---

### Обработка входящих тиков

В методе `onNext`:

1. **Фильтрация по типу сообщения**:
   - Обрабатываются только сообщения с торговой сделкой (`response.hasTrade()`).
2. **Извлечение параметров сделки**:
   - Время сделки переводится в миллисекунды (`timestampMs`);
   - Извлекается объем (`quantity`) и FIGI (`figi`).
3. **Фильтр по минимальному лоту**:
   - Если `quantity < MIN_LOT` — тик игнорируется.
4. **Агрегация тиков в окно `AGGREGATION_WINDOW_MS`**:
   - Берется буфер `buffer` для FIGI;
   - Если последний элемент в буфере по времени ближе, чем 50 мс:
     - обновляется его время на `timestampMs`;
     - объем увеличивается на `quantity`.
   - Иначе создается новая запись.
5. **Очистка устаревших записей**:
   - Все элементы с временем `< currentTime - TIME_WINDOW_MS` удаляются.
6. **Запуск детекции**:
   - При наличии в буфере не менее `MIN_SERIES_LENGTH` элементов вызывается `detectRobots(figi, buffer)`.

---

### Алгоритм детекции робота

В методе `detectRobots`:

1. **Подготовка данных**:
   - Из буфера формируются списки `timestamps` и `sizes`;
   - Для анализа берутся до 10 последних сделок (хвост).
2. **Определение актуального времени**:
   - `latestTs` — время последнего тика в текущем окне (используется для очистки списка роботов по таймауту).
3. **Очистка списка активных роботов**:
   - Для роботов с тем же FIGI:
     - если `latestTs - state.lastTickMs > ROBOT_TIMEOUT_MS`, робот удаляется из `activeRobots`.
4. **Группировка по лотам**:
   - Формируется `lotBuckets: Map<Long, List<Long>>`, где для каждого размера лота хранится список времен сделок.
   - «Почти одинаковые» лоты объединяются по правилу `|key - size| <= LOT_TOLERANCE`.
5. **Оценка стабильности интервала**:
   - Для каждой группы (конкретного лота) с числом сделок ≥ `MIN_SERIES_LENGTH` считается средний интервал и его дисперсия (`calculateMeanInterval`).
   - Если интервал нестабилен (коэффициент вариации > `INTERVAL_TOLERANCE`), группа отбрасывается.
6. **Регистрация или обновление робота**:
   - Для устойчивой группы:
     - вычисляется `intervalSec` (в секундах);
     - берется `lastTickMs` (последний тик серии);
     - формируется `robotKey = "<FIGI>|<lot>"`.
   - Если робота с таким ключом еще нет:
     - создается `RobotState`;
     - записывается в `activeRobots`;
     - в лог печатается строка со сведениями о роботе и временем последнего тика в МСК.
   - Если робот уже есть:
     - обновляются `lastTickMs` и `intervalSec`;
     - **новое сообщение в лог не выводится**.

Метод обрабатывает максимум одного «подходящего» робота за вызов и после этого делает `return`.

---

### Формат логов

При первом обнаружении нового робота выводится строка вида:

```text
Робот: <TICKER> Интервал=<INTERVAL_SEC> секунд, лот≈<LOT> (±0) Время последнего тика (МСК)=HH:mm:ss
```

Где:
- `<TICKER>` — тикер инструмента;
- `<INTERVAL_SEC>` — стабильный интервал между сделками в секундах;
- `<LOT>` — размер лота, по которому обнаружен робот;
- `HH:mm:ss` — время последнего тика по Москве.

Для уже зарегистрированных роботов лог повторно **не дублируется**; их состояние лишь обновляется во внутренней структуре `activeRobots`.

---

### Запуск

1. Установить корректный токен Tinkoff Invest API в классе `AdvancedRobotDetection` (рекомендуется вынести его из кода).
2. Собрать проект Maven‑ом:
   ```bash
   mvn clean package
   ```
3. Запустить приложение (пример, если собран исполняемый JAR):
   ```bash
   java -jar target/ShiftToScript-*.jar
   ```

Приложение запустит стрим сделок, будет непрерывно анализировать входящие данные и логировать обнаруженных роботов по описанным правилам.


